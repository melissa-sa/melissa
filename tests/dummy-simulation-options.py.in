# Copyright (c) 2017, Institut National de Recherche en Informatique et en Automatique (https://www.inria.fr/)
#               2017, EDF (https://www.edf.fr/)
#               2020, Institut National de Recherche en Informatique et en Automatique (https://www.inria.fr/)
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# * Redistributions of source code must retain the above copyright notice, this
#   list of conditions and the following disclaimer.
#
# * Redistributions in binary form must reproduce the above copyright notice,
#   this list of conditions and the following disclaimer in the documentation
#   and/or other materials provided with the distribution.
#
# * Neither the name of the copyright holder nor the names of its
#   contributors may be used to endorse or promote products derived from
#   this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

import numpy as np
import os
import subprocess
import time



# These variables are only used in this file.
BUILD_WITH_FLOWVR = 'OFF'
EXECUTABLE = 'dummy-simulation'
NODES_SERVER = 1
NODES_GROUP = 1
WALLTIME_SERVER = 300
WALLTIME_SIMU = 150
WORKDIR = "@CMAKE_CURRENT_BINARY_DIR@/workspace-dummy-simulation"

# The launch_server function to put in USER_FUNCTIONS['launch_server'].
# It takes a Server object as argument, and must set its job_id attribute.
# Here, we use the PID of the subprocess.
# The server object provides two important attributes:
#   path: the path to melissa_server executable
#   cmd_opt: the options set by the launcher to pass to the server.

def launch_server(server):
    if (not os.path.isdir(WORKDIR)):
        os.mkdir(WORKDIR)
    os.chdir(WORKDIR)
    print('mpirun ' + ' -n '+str(NODES_SERVER) + ' ' + server.path + '/melissa_server ' + server.cmd_opt + ' &')
    server.job_id = subprocess.Popen(('mpirun ' +
                                      ' -n '+str(NODES_SERVER) +
                                      '  ' +
                                      ' @CMAKE_BINARY_DIR@/server/melissa_server ' +
                                      server.cmd_opt +
                                      ' &').split()).pid
    os.chdir(WORKDIR)

# The launch_group function to put in USER_FUNCTIONS['launch_group'].
# It is used to launch batches of simulations (or groups of simulation the case of Sobol' indices computation).
# It takes a Group object as argument, and must set the job ID of the group of simulations in the attribute job_id of the Group object.
# This object provides three important attributes:
#   simu_id:
#   rank
#   param_set
# We distinguish three kinds of groups:

# Once we have set the job IDs of our jobs, we can use it to define the fault tolerance functions. In our case, we will use the same function for the server and the simulations. It takes a `Job` object as argument, and sets its `status` attribute to 0 if it is waiting to be scheduled, 1 if it is currently running, or 2 if it is not running anymore. In your local machine, a job will never be have a 0 status, because it is launched immediately when `USER_FUNCTIONS['launch_group']` is called.

def launch_group(group):
    if (not os.path.isdir(WORKDIR+"/group"+str(group.group_id))):
        os.mkdir(WORKDIR+"/group"+str(group.group_id))
    os.chdir(WORKDIR+"/group"+str(group.group_id))
    #os.environ['MELISSA_SERVER_NODE_NAME'] = group.server_node_name

    if group.ml_stats['sobol_indices']:

        # Sobol group: In the case of Sobol' indices computation, all the simulations of a Sobol' group must be in the same job.
        # In that case, simu_id is a list of the simulation IDs inside the Sobol' group (the ones you will pass to melissa_init), and rank is the ID of the group.
        # param_set is a list of size group.nb_param + 2 of numpy arrays of size group.nb_param, corresponding to the sets of n parameters of the n+2 simulations in the Sobol' group.

        if BUILD_WITH_FLOWVR == 'ON' and STUDY_OPTIONS['coupling'] == 'MELISSA_COUPLING_FLOWVR':
            raise NotImplementedError('FlowVR coupling')
        else:
            #os.environ['MELISSA_MASTER_NODE_NAME'] = socket.gethostname()
            command = 'mpirun '
            for i, simu_id in enumerate(group.simu_id):
                command += ' '.join(('-n',
                                     str(NODES_GROUP),
                                     '-x',
                                     'MELISSA_SIMU_ID='+str(simu_id),
                                     '-x',
                                     'MELISSA_COUPLING='+str(group.coupling),
                                     '-x',
                                     'MELISSA_SERVER_NODE_NAME='+str(group.server_node_name),
                                     ' @CMAKE_CURRENT_BINARY_DIR@/dummy-simulation',
                                     ' '.join(str(j) for j in group.param_set[i]),
                                     ': '))
            print(command[:-2])
            group.job_id = subprocess.Popen(command[:-2].split()).pid

    else:

        # Batch of simulations: Multiple simulations are launched in the same job.
        # In that case, simu_id is a list of the simulation IDs of size STUDY_OPTIONS['batch_size'] (the ones you will pass to melissa_init in your solver), and rank is the ID of the group.
        # param_set is a list of size STUDY_OPTIONS['batch_size'] of numpy arrays of size group.nb_param.
        # The parameter STUDY_OPTIONS['sampling_size'] must be a multiple of STUDY_OPTIONS['batch_size'].

        command = 'mpirun '
        for i in range(group.size):
            command += ' '.join(('-n',
                                 str(NODES_GROUP),
                                 '-x',
                                 'MELISSA_SIMU_ID='+str(group.simu_id[i]),
                                 '-x',
                                 'MELISSA_SERVER_NODE_NAME='+str(group.server_node_name),
                                 '@CMAKE_CURRENT_BINARY_DIR@/dummy-simulation',
                                 ' '.join(str(j) for j in group.param_set[i]),
                                 ': '))
        print(command[:-2])
        #os.environ['MELISSA_MASTER_NODE_NAME'] = socket.gethostname()
        group.job_id = subprocess.Popen(command[:-2].split()).pid

    os.chdir(WORKDIR)

def check_job(job):
    # Check the job state:
    # 0: not runing
    # 1: running
    # 2: not running anymore (finished or crashed)
    state = 0
    try:
        subprocess.check_output(["ps",str(job.job_id)])
        state = 1
    except:
        state = 2
    # we set the job_status attribute of the Job object. Group and Server objects inherite of Job.
    job.job_status = state

def check_load():
    # We only run one group at a time
    #time.sleep(1)
    time.sleep(1)
    try:
        out = str(subprocess.check_output(["pidof",EXECUTABLE])).split()
    except:
        return True
    if len(out) > 3:
        return False
    else:
        time.sleep(2)
        return True

def kill_job(job):
    os.system('kill '+str(job.job_id))

def draw_param_set():
    param_set = np.random.uniform(0, 1, size=2)
    return param_set




STUDY_OPTIONS = {}
# number of varying parameters of the study
STUDY_OPTIONS['nb_parameters'] = 1
# initial number of parameter sets
STUDY_OPTIONS['sampling_size'] = 6
# number of timesteps, from Melissa point of view
STUDY_OPTIONS['nb_timesteps'] = 2
STUDY_OPTIONS['threshold_values'] = [0.7, 0.8]
STUDY_OPTIONS['quantile_values'] = [0.05,0.25,0.5,0.75,0.95]
# list of field names
STUDY_OPTIONS['field_names'] = ["heat1"]
# simulations are restarted after this amount of seconds
STUDY_OPTIONS['simulation_timeout'] = 200
# server checkpoint interval in seconds
STUDY_OPTIONS['checkpoint_interval'] = 150
# option for Sobol' simulation groups coupling
STUDY_OPTIONS['coupling'] = "MELISSA_COUPLING_MPI"
# verbosity (the default level is 2):
# * 0: show only errors
# * 1: show errors and warnings
# * 2: show errors, warnings, and useful information
# * 3: show errors, warnings, useful information, and debugging data
STUDY_OPTIONS['verbosity'] = 2
STUDY_OPTIONS['batch_size'] = 2
STUDY_OPTIONS['resp_port'] = 5546
STUDY_OPTIONS['recv_port'] = 5547
STUDY_OPTIONS['send_port'] = 5548

MELISSA_STATS = {}
MELISSA_STATS['mean'] = True
MELISSA_STATS['variance'] = False
MELISSA_STATS['skewness'] = False
MELISSA_STATS['kurtosis'] = False
MELISSA_STATS['min'] = True
MELISSA_STATS['max'] = True
MELISSA_STATS['threshold_exceedance'] = True
MELISSA_STATS['quantiles'] = True
MELISSA_STATS['sobol_indices'] = True

USER_FUNCTIONS = {}
USER_FUNCTIONS['create_study'] = None
USER_FUNCTIONS['draw_parameter_set'] = draw_param_set
USER_FUNCTIONS['create_group'] = None
USER_FUNCTIONS['launch_group'] = launch_group
USER_FUNCTIONS['launch_server'] = launch_server
USER_FUNCTIONS['check_server_job'] = check_job
USER_FUNCTIONS['check_group_job'] = check_job
USER_FUNCTIONS['restart_server'] = launch_server
USER_FUNCTIONS['restart_group'] = None
USER_FUNCTIONS['check_scheduler_load'] = check_load
USER_FUNCTIONS['cancel_job'] = kill_job
USER_FUNCTIONS['postprocessing'] = None
USER_FUNCTIONS['finalize'] = None
